# Решение нелинейных уравнений
# 1 - Импротирование модулей для вычисления производной и построения графиков
# 2 - Описание первоначальной функции, метода нахождения точек и производной, эквивалентной функции и её производной
# 3 - Описание численных методов нахождения корня. Представлены метод дихотомии, метод простых итераций и метод Ньютона

from sympy import * #symbols, diff
import numpy as np
x = symbols('x')
import matplotlib.pyplot as plt

# Здесь происходит отрисовка графиков для нахождения пересечений с осью абсцисс
def graphics():
    args = [];
    fargs = [];
    gargs = []
    plt.title('plot', fontsize=22)
    for j in range(-5000, 5000):
        i = j / 1000
        args.append(i)
        fargs.append(f(i))
        gargs.append(0)
    plt.grid(True)
    plt.plot(args, fargs,args,gargs)
    plt.show()
    pass

# Здесь обозначена функция, которую нужно будет приравнивать к нулю для решения уравнения
def f(x):
    return x ** 2 - 2

# Здесь находится производная изначальной функции, а также её значение в точке
def df(num):
    # sympy с помощью функции diff, которая приставляется к изначальной функции
    # (а она ранее обозначена за f) находится производная, которая приводится
    # к виду функции, работающей с числами, после чего находится значение производной в точке
    y = f(x).diff(x)
    z = lambdify(x, y, 'numpy')
    return z(num)

# Здесь располагается изменение функции для возможности реализации метода простых итераций
def g(x,n):
    #деление аргумента и добавление переменной, необходимой для реализации метода итераций
    g = f(x/n)+x/n
    return g

# Производная от функции в методе простых итераций, нужна для проверки условия
def dg(n, num):
    y = g(x, num).diff(x)
    z = lambdify(x, y, 'numpy')
    return z(num)

def fi(x):
    y = (x+2/x)/2
    return y

# Здесь проверяется промежуток на наличие нуля функции с помощью перемножения значений функции в концевых точках
# Защиты от функций без нулей нет,также не проверяется область определения функций
# Результатом будет пара точек, между которыми находится корень(или сами точки являются корнем)
def points():
    # Начальные точки, от которых будет идти поиск промежутка и число для перемещения отрезка
    x1 = 0;
    x2 = 1;
    n = 1
    # Проверка на смену знака где-то на интервале
    while (f(x1) * f(x2) > 0):
        # Блок по смещению точек промежутка
        x1 += n
        x2 += n
        if (n > 0):
            n += 1
        else:
            n -= 1
        n *= (-1)
    # Проверка закончилась, выводятся точки
    return x1, x2

#dixotomia
def dixotomy(x1, x2):
    # обозначить точность
    epsilon = 0.00001
    # локальные переменные, внешние нужны в других методах в изначальном виде
    v1 = x1;
    v2 = x2;

    while (abs(v1 - v2) > epsilon):
        # установление середины
        v0 = (v1 + v2) / 2
        # проверка и выбор отрезка для дальнейшей работы
        if (f(v1) * f(v0) <= 0):
            v2 = v0
        else:
            v1 = v0
    return (v1+v2)/2

def simple_iterations_1(x1, x2):#я сдаюсь
    #обозначить точность и начальное значение для поиска корня
    epsilon = 0.00001
    v1 = (x1+x2)/2
    n = 1
    # преобразование функции для возможности работы
    while(dg(n,v1)>=1):
        n+=1
        v1=(x1+x2)/2
        v1 = v1 * n
    #print("n = ",n)
    #print("v1 = ",v1)
    v2 = 0
    # непосредственно итерации
    while (abs(v1-v2)>epsilon):
        v2 = v1
        v1 = g(v2,n)

    return v1

def simple_iterations_2(x1, x2):#я сдаюсь
    #обозначить точность и начальное значение для поиска корня
    epsilon = 0.00001
    v1 = (x1+x2)/2
    v2 = 0
    # непосредственно итерации
    while (abs(v1-v2)>epsilon):
        v2 = v1
        v1 = fi(v2)
    return v1

# метод Ньютона
def newton(x1,x2):
    # Примечательно то, что можно взять вообще любую точку из отрезка для нахождения с помощью метода Ньютона
    v1 = (x1+x2)/2
    # Локальная переменная для сохранения предыдущего значения, что понадобится
    # при выяснении точности вычисления
    v2 = 0
    epsilon = 0.00001
    while (abs(v1-v2)>epsilon):
        v2 = v1
        # само выражения для вычисления
        v1 = v2 - (f(v2)/df(v2))
    return v1

print(dixotomy(points()[0],points()[1]))
print(simple_iterations_1(points()[0],points()[1]))
print(simple_iterations_2(points()[0],points()[1]))
print(newton(points()[0],points()[1]))
graphics()
